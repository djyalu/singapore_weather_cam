# üéØ Singapore Weather Cam - Íµ¨ÌòÑ Ìå®ÌÑ¥ Î∞è Î≤†Ïä§Ìä∏ ÌîÑÎûôÌã∞Ïä§

## üìã Î™©Ï∞®

1. [React Ìå®ÌÑ¥ Í∞ÄÏù¥Îìú](#react-Ìå®ÌÑ¥-Í∞ÄÏù¥Îìú)
2. [ÏÉÅÌÉú Í¥ÄÎ¶¨ Ìå®ÌÑ¥](#ÏÉÅÌÉú-Í¥ÄÎ¶¨-Ìå®ÌÑ¥)
3. [API ÌÜµÌï© Ìå®ÌÑ¥](#api-ÌÜµÌï©-Ìå®ÌÑ¥)
4. [ÏóêÎü¨ Ï≤òÎ¶¨ Ìå®ÌÑ¥](#ÏóêÎü¨-Ï≤òÎ¶¨-Ìå®ÌÑ¥)
5. [ÏÑ±Îä• ÏµúÏ†ÅÌôî Ìå®ÌÑ¥](#ÏÑ±Îä•-ÏµúÏ†ÅÌôî-Ìå®ÌÑ¥)
6. [ÌÖåÏä§ÌåÖ Ìå®ÌÑ¥](#ÌÖåÏä§ÌåÖ-Ìå®ÌÑ¥)
7. [Ï†ëÍ∑ºÏÑ± Ìå®ÌÑ¥](#Ï†ëÍ∑ºÏÑ±-Ìå®ÌÑ¥)

---

## ‚öõÔ∏è React Ìå®ÌÑ¥ Í∞ÄÏù¥Îìú

### 1. Ïª¥Ìè¨ÎÑåÌä∏ ÏÑ§Í≥Ñ Ìå®ÌÑ¥

#### **Ïª¥Ìè¨ÎÑåÌä∏ Î∂ÑÎ•ò Î∞è Íµ¨Ï°∞**

```javascript
/**
 * Ïª¥Ìè¨ÎÑåÌä∏ Î∂ÑÎ•ò Ï≤¥Í≥Ñ
 * 
 * 1. Presentational Components (ÏàúÏàò ÌëúÌòÑ Ïª¥Ìè¨ÎÑåÌä∏)
 * 2. Container Components (ÎπÑÏ¶àÎãàÏä§ Î°úÏßÅ Ïª¥Ìè¨ÎÑåÌä∏)
 * 3. Higher-Order Components (Í≥†Ï∞® Ïª¥Ìè¨ÎÑåÌä∏)
 * 4. Custom Hooks (Ïª§Ïä§ÌÖÄ ÌõÖ)
 */

// ‚úÖ Ï¢ãÏùÄ Ïòà: Presentational Component
const WeatherCard = React.memo(({ 
  location, 
  temperature, 
  humidity, 
  onRefresh,
  isLoading = false 
}) => {
  return (
    <div className="weather-card" role="region" aria-labelledby={`weather-${location.id}`}>
      <h3 id={`weather-${location.id}`}>{location.displayName}</h3>
      <div className="weather-data">
        <span aria-label={`Temperature ${temperature} degrees celsius`}>
          {temperature}¬∞C
        </span>
        <span aria-label={`Humidity ${humidity} percent`}>
          {humidity}%
        </span>
      </div>
      {isLoading ? (
        <div aria-live="polite">Updating...</div>
      ) : (
        <button 
          onClick={onRefresh}
          aria-label={`Refresh weather data for ${location.displayName}`}
        >
          Refresh
        </button>
      )}
    </div>
  );
});

// Props ÌÉÄÏûÖ Í≤ÄÏ¶ù
WeatherCard.propTypes = {
  location: PropTypes.shape({
    id: PropTypes.string.isRequired,
    displayName: PropTypes.string.isRequired
  }).isRequired,
  temperature: PropTypes.number.isRequired,
  humidity: PropTypes.number.isRequired,
  onRefresh: PropTypes.func.isRequired,
  isLoading: PropTypes.bool
};

// ‚úÖ Ï¢ãÏùÄ Ïòà: Container Component
const WeatherCardContainer = ({ locationId }) => {
  const { weatherData, loading, error, refresh } = useWeatherData(locationId);
  const { trackUserInteraction } = useMetrics();
  
  const handleRefresh = useCallback(() => {
    trackUserInteraction('refresh', 'weather-card', { locationId });
    refresh();
  }, [locationId, refresh, trackUserInteraction]);

  if (error) {
    return <ErrorDisplay error={error} onRetry={handleRefresh} />;
  }

  if (!weatherData) {
    return <WeatherCardSkeleton />;
  }

  return (
    <WeatherCard
      location={weatherData.location}
      temperature={weatherData.temperature}
      humidity={weatherData.humidity}
      onRefresh={handleRefresh}
      isLoading={loading}
    />
  );
};
```

#### **Ïª§Ïä§ÌÖÄ ÌõÖ Ìå®ÌÑ¥**

```javascript
/**
 * Ïª§Ïä§ÌÖÄ ÌõÖ ÏÑ§Í≥Ñ ÏõêÏπô
 * 
 * 1. Single Responsibility: ÌïòÎÇòÏùò Ï±ÖÏûÑÎßå Í∞ÄÏßê
 * 2. Composable: Îã§Î•∏ ÌõÖÍ≥º Ï°∞Ìï© Í∞ÄÎä•
 * 3. Reusable: Ïû¨ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Î°úÏßÅ
 * 4. Testable: ÎèÖÎ¶ΩÏ†ÅÏúºÎ°ú ÌÖåÏä§Ìä∏ Í∞ÄÎä•
 */

// ‚úÖ Ï¢ãÏùÄ Ïòà: ÌäπÏ†ï Í∏∞Îä•Ïóê ÏßëÏ§ëÎêú ÌõÖ
export const useWeatherData = (locationId, options = {}) => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [lastFetch, setLastFetch] = useState(null);
  
  const {
    refreshInterval = 5 * 60 * 1000,
    enableAutoRefresh = true,
    retryAttempts = 3
  } = options;

  // Îç∞Ïù¥ÌÑ∞ ÌéòÏπ≠ Î°úÏßÅ
  const fetchData = useCallback(async () => {
    if (!locationId) return;
    
    try {
      setLoading(true);
      setError(null);
      
      const result = await apiService.fetch(`/weather/${locationId}`, {
        cacheTTL: 2 * 60 * 1000 // 2Î∂Ñ Ï∫êÏãú
      });
      
      // Î≥¥Ïïà Í≤ÄÏ¶ù
      const validation = securityValidator.validateWeatherData(result);
      if (!validation.isValid) {
        throw new Error(`Data validation failed: ${validation.errors.join(', ')}`);
      }
      
      setData(validation.sanitized);
      setLastFetch(new Date());
      
    } catch (err) {
      console.error('Weather data fetch error:', err);
      setError(err);
      
      // ÏóêÎü¨ Î©îÌä∏Î¶≠ Í∏∞Î°ù
      metricsService.trackError('weather_fetch_error', {
        locationId,
        error: err.message
      });
      
    } finally {
      setLoading(false);
    }
  }, [locationId]);

  // ÏûêÎèô ÏÉàÎ°úÍ≥†Ïπ®
  useEffect(() => {
    fetchData();
    
    if (enableAutoRefresh) {
      const interval = setInterval(fetchData, refreshInterval);
      return () => clearInterval(interval);
    }
  }, [fetchData, enableAutoRefresh, refreshInterval]);

  // ÏàòÎèô ÏÉàÎ°úÍ≥†Ïπ®
  const refresh = useCallback(() => {
    fetchData();
  }, [fetchData]);

  // Îç∞Ïù¥ÌÑ∞ Ïã†ÏÑ†ÎèÑ Í≥ÑÏÇ∞
  const dataFreshness = useMemo(() => {
    if (!lastFetch) return null;
    
    const now = new Date();
    const diffMinutes = Math.floor((now - lastFetch) / (1000 * 60));
    
    if (diffMinutes < 1) return 'just now';
    if (diffMinutes < 60) return `${diffMinutes}m ago`;
    
    const diffHours = Math.floor(diffMinutes / 60);
    return `${diffHours}h ago`;
  }, [lastFetch]);

  return {
    data,
    loading,
    error,
    refresh,
    lastFetch,
    dataFreshness,
    isStale: lastFetch && (Date.now() - lastFetch) > refreshInterval
  };
};

// ‚úÖ Ï¢ãÏùÄ Ïòà: Ï°∞Ìï© Í∞ÄÎä•Ìïú ÌõÖ
export const useWeatherLocations = () => {
  const [selectedLocation, setSelectedLocation] = useState('bukit_timah_nature_reserve');
  const [favoriteLocations, setFavoriteLocations] = useState(() => {
    return JSON.parse(localStorage.getItem('favoriteLocations') || '[]');
  });

  // Ï¶êÍ≤®Ï∞æÍ∏∞ Í¥ÄÎ¶¨
  const toggleFavorite = useCallback((locationId) => {
    setFavoriteLocations(prev => {
      const updated = prev.includes(locationId)
        ? prev.filter(id => id !== locationId)
        : [...prev, locationId];
      
      localStorage.setItem('favoriteLocations', JSON.stringify(updated));
      return updated;
    });
  }, []);

  // ÏúÑÏπò Î≥ÄÍ≤Ω
  const selectLocation = useCallback((locationId) => {
    setSelectedLocation(locationId);
    
    // Î©îÌä∏Î¶≠ Ï∂îÏ†Å
    metricsService.trackUserInteraction('location_select', locationId);
  }, []);

  return {
    selectedLocation,
    favoriteLocations,
    selectLocation,
    toggleFavorite,
    isFavorite: (locationId) => favoriteLocations.includes(locationId)
  };
};

// ‚úÖ ÌõÖ Ï°∞Ìï© ÏÇ¨Ïö© ÏòàÏ†ú
const WeatherLocationCard = ({ locationId }) => {
  const { data, loading, error, refresh } = useWeatherData(locationId);
  const { isFavorite, toggleFavorite } = useWeatherLocations();
  
  return (
    <WeatherCard
      data={data}
      loading={loading}
      error={error}
      onRefresh={refresh}
      isFavorite={isFavorite(locationId)}
      onToggleFavorite={() => toggleFavorite(locationId)}
    />
  );
};
```

### 2. Í≥†Í∏â React Ìå®ÌÑ¥

#### **Compound Components Ìå®ÌÑ¥**

```javascript
/**
 * Compound Components Ìå®ÌÑ¥
 * Ïó¨Îü¨ Ïª¥Ìè¨ÎÑåÌä∏Í∞Ä Ìï®Íªò ÏûëÎèôÌïòÏó¨ ÌïòÎÇòÏùò Í∏∞Îä•ÏùÑ Ï†úÍ≥µ
 */

// ‚úÖ Ï¢ãÏùÄ Ïòà: Weather Dashboard Compound Component
const WeatherDashboard = ({ children, data, onLocationChange }) => {
  const [selectedLocation, setSelectedLocation] = useState(null);
  const [viewMode, setViewMode] = useState('cards');

  const contextValue = {
    data,
    selectedLocation,
    viewMode,
    onLocationSelect: (locationId) => {
      setSelectedLocation(locationId);
      onLocationChange?.(locationId);
    },
    onViewModeChange: setViewMode
  };

  return (
    <WeatherDashboardContext.Provider value={contextValue}>
      <div className="weather-dashboard">
        {children}
      </div>
    </WeatherDashboardContext.Provider>
  );
};

// ÏÑúÎ∏å Ïª¥Ìè¨ÎÑåÌä∏Îì§
WeatherDashboard.Header = ({ title, children }) => {
  const { viewMode, onViewModeChange } = useContext(WeatherDashboardContext);
  
  return (
    <div className="dashboard-header">
      <h2>{title}</h2>
      <div className="view-controls">
        <button 
          className={viewMode === 'cards' ? 'active' : ''}
          onClick={() => onViewModeChange('cards')}
        >
          Cards
        </button>
        <button 
          className={viewMode === 'chart' ? 'active' : ''}
          onClick={() => onViewModeChange('chart')}
        >
          Chart
        </button>
      </div>
      {children}
    </div>
  );
};

WeatherDashboard.LocationSelector = ({ locations }) => {
  const { selectedLocation, onLocationSelect } = useContext(WeatherDashboardContext);
  
  return (
    <div className="location-selector">
      {locations.map(location => (
        <button
          key={location.id}
          className={selectedLocation === location.id ? 'selected' : ''}
          onClick={() => onLocationSelect(location.id)}
        >
          {location.displayName}
        </button>
      ))}
    </div>
  );
};

WeatherDashboard.Content = () => {
  const { data, viewMode, selectedLocation } = useContext(WeatherDashboardContext);
  
  const filteredData = selectedLocation 
    ? data.filter(item => item.id === selectedLocation)
    : data;

  if (viewMode === 'cards') {
    return (
      <div className="weather-cards">
        {filteredData.map(item => (
          <WeatherCard key={item.id} data={item} />
        ))}
      </div>
    );
  }

  return <WeatherChart data={filteredData} />;
};

// ÏÇ¨Ïö© ÏòàÏ†ú
const App = () => {
  const { weatherData } = useWeatherData();
  
  return (
    <WeatherDashboard data={weatherData} onLocationChange={trackLocationChange}>
      <WeatherDashboard.Header title="Weather Overview">
        <RefreshButton />
      </WeatherDashboard.Header>
      
      <WeatherDashboard.LocationSelector locations={availableLocations} />
      
      <WeatherDashboard.Content />
    </WeatherDashboard>
  );
};
```

#### **Render Props Ìå®ÌÑ¥**

```javascript
/**
 * Render Props Ìå®ÌÑ¥
 * Ïª¥Ìè¨ÎÑåÌä∏ Í∞Ñ Î°úÏßÅ Í≥µÏú†Î•º ÏúÑÌïú Ìå®ÌÑ¥
 */

// ‚úÖ Ï¢ãÏùÄ Ïòà: Data Fetcher with Render Props
const DataFetcher = ({ 
  url, 
  children,
  fallback = null,
  errorComponent: ErrorComponent = DefaultErrorComponent 
}) => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        setLoading(true);
        setError(null);
        
        const result = await apiService.fetch(url);
        setData(result);
        
      } catch (err) {
        setError(err);
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, [url]);

  if (loading) return fallback || <LoadingSpinner />;
  if (error) return <ErrorComponent error={error} />;

  return children({ data, loading, error, refetch: fetchData });
};

// ÏÇ¨Ïö© ÏòàÏ†ú
const WeatherDisplay = () => (
  <DataFetcher 
    url="/api/weather"
    fallback={<WeatherSkeleton />}
    errorComponent={WeatherErrorDisplay}
  >
    {({ data, refetch }) => (
      <div>
        <WeatherCards data={data} />
        <button onClick={refetch}>Refresh</button>
      </div>
    )}
  </DataFetcher>
);
```

---

## üìä ÏÉÅÌÉú Í¥ÄÎ¶¨ Ìå®ÌÑ¥

### 1. Î°úÏª¨ ÏÉÅÌÉú Í¥ÄÎ¶¨

#### **useState ÏµúÏ†ÅÌôî Ìå®ÌÑ¥**

```javascript
/**
 * useState ÏµúÏ†ÅÌôî Í∏∞Î≤ï
 */

// ‚úÖ Ï¢ãÏùÄ Ïòà: Lazy Initial State
const useExpensiveState = () => {
  const [data, setData] = useState(() => {
    // ÎπÑÏö©Ïù¥ ÌÅ∞ Ï¥àÍ∏∞Ìôî Î°úÏßÅ
    return processLargeDataset();
  });

  return [data, setData];
};

// ‚úÖ Ï¢ãÏùÄ Ïòà: Functional State Updates
const useCounter = (initialValue = 0) => {
  const [count, setCount] = useState(initialValue);

  const increment = useCallback(() => {
    setCount(prevCount => prevCount + 1);
  }, []);

  const decrement = useCallback(() => {
    setCount(prevCount => prevCount - 1);
  }, []);

  const reset = useCallback(() => {
    setCount(initialValue);
  }, [initialValue]);

  return { count, increment, decrement, reset };
};

// ‚úÖ Ï¢ãÏùÄ Ïòà: Î≥µÏû°Ìïú ÏÉÅÌÉúÎ•º ÏúÑÌïú useReducer
const weatherDashboardReducer = (state, action) => {
  switch (action.type) {
    case 'SET_LOADING':
      return {
        ...state,
        loading: action.payload,
        error: null
      };

    case 'SET_DATA':
      return {
        ...state,
        data: action.payload,
        loading: false,
        error: null,
        lastUpdate: new Date()
      };

    case 'SET_ERROR':
      return {
        ...state,
        error: action.payload,
        loading: false
      };

    case 'SET_FILTER':
      return {
        ...state,
        filters: {
          ...state.filters,
          [action.payload.key]: action.payload.value
        }
      };

    case 'RESET_FILTERS':
      return {
        ...state,
        filters: initialFilters
      };

    default:
      return state;
  }
};

const useWeatherDashboard = () => {
  const [state, dispatch] = useReducer(weatherDashboardReducer, {
    data: null,
    loading: true,
    error: null,
    filters: initialFilters,
    lastUpdate: null
  });

  const setData = useCallback((data) => {
    dispatch({ type: 'SET_DATA', payload: data });
  }, []);

  const setError = useCallback((error) => {
    dispatch({ type: 'SET_ERROR', payload: error });
  }, []);

  const setFilter = useCallback((key, value) => {
    dispatch({ type: 'SET_FILTER', payload: { key, value } });
  }, []);

  return {
    ...state,
    setData,
    setError,
    setFilter,
    resetFilters: () => dispatch({ type: 'RESET_FILTERS' })
  };
};
```

### 2. Ï†ÑÏó≠ ÏÉÅÌÉú Í¥ÄÎ¶¨

#### **Context + useReducer Ìå®ÌÑ¥**

```javascript
/**
 * Ï†ÑÏó≠ ÏÉÅÌÉú Í¥ÄÎ¶¨Î•º ÏúÑÌïú Context + useReducer
 */

// Ïï± Ï†ÑÏó≠ ÏÉÅÌÉú Ï†ïÏùò
const AppStateContext = createContext();
const AppDispatchContext = createContext();

const appReducer = (state, action) => {
  switch (action.type) {
    case 'SET_USER_PREFERENCES':
      return {
        ...state,
        userPreferences: {
          ...state.userPreferences,
          ...action.payload
        }
      };

    case 'SET_THEME':
      return {
        ...state,
        theme: action.payload
      };

    case 'ADD_NOTIFICATION':
      return {
        ...state,
        notifications: [
          ...state.notifications,
          {
            id: Date.now(),
            ...action.payload
          }
        ]
      };

    case 'REMOVE_NOTIFICATION':
      return {
        ...state,
        notifications: state.notifications.filter(
          notification => notification.id !== action.payload
        )
      };

    default:
      return state;
  }
};

// Provider Ïª¥Ìè¨ÎÑåÌä∏
export const AppStateProvider = ({ children }) => {
  const [state, dispatch] = useReducer(appReducer, {
    userPreferences: {
      language: 'ko',
      units: 'metric',
      refreshInterval: 5 * 60 * 1000
    },
    theme: 'light',
    notifications: []
  });

  return (
    <AppStateContext.Provider value={state}>
      <AppDispatchContext.Provider value={dispatch}>
        {children}
      </AppDispatchContext.Provider>
    </AppStateContext.Provider>
  );
};

// Ïª§Ïä§ÌÖÄ ÌõÖÏúºÎ°ú Ìé∏Î¶¨Ìïú ÏÇ¨Ïö©
export const useAppState = () => {
  const context = useContext(AppStateContext);
  if (!context) {
    throw new Error('useAppState must be used within AppStateProvider');
  }
  return context;
};

export const useAppDispatch = () => {
  const context = useContext(AppDispatchContext);
  if (!context) {
    throw new Error('useAppDispatch must be used within AppStateProvider');
  }
  return context;
};

// Ïï°ÏÖò ÌÅ¨Î¶¨ÏóêÏù¥ÌÑ∞
export const useAppActions = () => {
  const dispatch = useAppDispatch();

  return {
    setUserPreferences: (preferences) => 
      dispatch({ type: 'SET_USER_PREFERENCES', payload: preferences }),
    
    setTheme: (theme) => 
      dispatch({ type: 'SET_THEME', payload: theme }),
    
    addNotification: (notification) => 
      dispatch({ type: 'ADD_NOTIFICATION', payload: notification }),
    
    removeNotification: (id) => 
      dispatch({ type: 'REMOVE_NOTIFICATION', payload: id })
  };
};
```

---

## üîå API ÌÜµÌï© Ìå®ÌÑ¥

### 1. API ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ìå®ÌÑ¥

#### **ÌÉÄÏûÖ ÏïàÏ†Ñ API ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏**

```javascript
/**
 * ÌÉÄÏûÖ ÏïàÏ†ÑÌïòÍ≥† ÌôïÏû• Í∞ÄÎä•Ìïú API ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏
 */

class WeatherAPIClient {
  constructor(baseURL, options = {}) {
    this.baseURL = baseURL;
    this.defaultOptions = {
      timeout: 10000,
      retries: 3,
      ...options
    };
    
    this.interceptors = {
      request: [],
      response: []
    };
  }

  // ÏöîÏ≤≠ Ïù∏ÌÑ∞ÏÖâÌÑ∞ Ï∂îÍ∞Ä
  addRequestInterceptor(interceptor) {
    this.interceptors.request.push(interceptor);
  }

  // ÏùëÎãµ Ïù∏ÌÑ∞ÏÖâÌÑ∞ Ï∂îÍ∞Ä
  addResponseInterceptor(interceptor) {
    this.interceptors.response.push(interceptor);
  }

  // Í∏∞Î≥∏ ÏöîÏ≤≠ Î©îÏÑúÎìú
  async request(endpoint, options = {}) {
    const url = `${this.baseURL}${endpoint}`;
    const config = {
      ...this.defaultOptions,
      ...options,
      headers: {
        'Content-Type': 'application/json',
        ...this.defaultOptions.headers,
        ...options.headers
      }
    };

    // ÏöîÏ≤≠ Ïù∏ÌÑ∞ÏÖâÌÑ∞ Ïã§Ìñâ
    let finalConfig = config;
    for (const interceptor of this.interceptors.request) {
      finalConfig = await interceptor(finalConfig);
    }

    try {
      let response = await fetch(url, finalConfig);
      
      // ÏùëÎãµ Ïù∏ÌÑ∞ÏÖâÌÑ∞ Ïã§Ìñâ
      for (const interceptor of this.interceptors.response) {
        response = await interceptor(response);
      }

      if (!response.ok) {
        throw new APIError(
          `HTTP ${response.status}: ${response.statusText}`,
          response.status,
          response
        );
      }

      return await response.json();
      
    } catch (error) {
      if (error instanceof APIError) {
        throw error;
      }
      
      throw new APIError(
        `Network error: ${error.message}`,
        0,
        null,
        error
      );
    }
  }

  // Ìé∏Ïùò Î©îÏÑúÎìúÎì§
  async get(endpoint, params = {}) {
    const queryString = new URLSearchParams(params).toString();
    const url = queryString ? `${endpoint}?${queryString}` : endpoint;
    
    return this.request(url, { method: 'GET' });
  }

  async post(endpoint, data) {
    return this.request(endpoint, {
      method: 'POST',
      body: JSON.stringify(data)
    });
  }

  // ÌäπÌôîÎêú API Î©îÏÑúÎìúÎì§
  async getWeatherData(locationId, options = {}) {
    const response = await this.get(`/weather/${locationId}`, {
      include: 'forecast,alerts',
      units: 'metric',
      ...options
    });

    // ÏùëÎãµ Í≤ÄÏ¶ù
    const validation = securityValidator.validateWeatherData(response);
    if (!validation.isValid) {
      throw new ValidationError('Invalid weather data', validation.errors);
    }

    return validation.sanitized;
  }

  async getTrafficCameras(area = null) {
    const params = area ? { area } : {};
    const response = await this.get('/traffic/cameras', params);

    // Ïπ¥Î©îÎùº Îç∞Ïù¥ÌÑ∞ Í≤ÄÏ¶ù Î∞è Ï†ïÏ†ú
    const validatedCameras = response.cameras
      .map(camera => {
        const validation = securityValidator.validateCameraData(camera);
        return validation.isValid ? validation.sanitized : null;
      })
      .filter(Boolean);

    return {
      ...response,
      cameras: validatedCameras,
      totalValid: validatedCameras.length
    };
  }
}

// ÏóêÎü¨ ÌÅ¥ÎûòÏä§Îì§
class APIError extends Error {
  constructor(message, status, response, originalError = null) {
    super(message);
    this.name = 'APIError';
    this.status = status;
    this.response = response;
    this.originalError = originalError;
  }
}

class ValidationError extends Error {
  constructor(message, validationErrors) {
    super(message);
    this.name = 'ValidationError';
    this.validationErrors = validationErrors;
  }
}

// API ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ±
const weatherAPI = new WeatherAPIClient('https://api.data.gov.sg/v1', {
  timeout: 15000,
  retries: 3
});

// Ïù∏ÌÑ∞ÏÖâÌÑ∞ ÏÑ§Ï†ï
weatherAPI.addRequestInterceptor(async (config) => {
  // ÏöîÏ≤≠ Î©îÌä∏Î¶≠ Ï∂îÏ†Å
  metricsService.trackAPICall('request_start', config.url);
  
  // Î≥¥Ïïà Ìó§Îçî Ï∂îÍ∞Ä
  config.headers['X-Client-Version'] = process.env.REACT_APP_VERSION;
  config.headers['X-Request-ID'] = generateRequestId();
  
  return config;
});

weatherAPI.addResponseInterceptor(async (response) => {
  // ÏùëÎãµ Î©îÌä∏Î¶≠ Ï∂îÏ†Å
  metricsService.trackAPICall('response_received', response.url, {
    status: response.status,
    size: response.headers.get('content-length')
  });
  
  return response;
});
```

### 2. Î∞òÏùëÌòï Îç∞Ïù¥ÌÑ∞ Ìå®ÌÑ¥

#### **Real-time Data Synchronization**

```javascript
/**
 * Ïã§ÏãúÍ∞Ñ Îç∞Ïù¥ÌÑ∞ ÎèôÍ∏∞Ìôî Ìå®ÌÑ¥
 */

class DataSynchronizer {
  constructor() {
    this.subscriptions = new Map();
    this.cache = new Map();
    this.syncInterval = 30000; // 30Ï¥à
    this.isOnline = navigator.onLine;
    
    this.setupNetworkListeners();
  }

  setupNetworkListeners() {
    window.addEventListener('online', () => {
      this.isOnline = true;
      this.resumeSync();
    });
    
    window.addEventListener('offline', () => {
      this.isOnline = false;
      this.pauseSync();
    });
  }

  subscribe(key, fetcher, options = {}) {
    const subscription = {
      key,
      fetcher,
      options: {
        interval: this.syncInterval,
        priority: 'normal',
        ...options
      },
      lastFetch: null,
      intervalId: null,
      subscribers: new Set()
    };

    this.subscriptions.set(key, subscription);
    this.startSync(key);
    
    return {
      unsubscribe: () => this.unsubscribe(key),
      getData: () => this.cache.get(key),
      forceRefresh: () => this.fetchData(key)
    };
  }

  addSubscriber(key, callback) {
    const subscription = this.subscriptions.get(key);
    if (subscription) {
      subscription.subscribers.add(callback);
    }
  }

  removeSubscriber(key, callback) {
    const subscription = this.subscriptions.get(key);
    if (subscription) {
      subscription.subscribers.delete(callback);
    }
  }

  async fetchData(key) {
    const subscription = this.subscriptions.get(key);
    if (!subscription || !this.isOnline) return;

    try {
      const startTime = Date.now();
      const data = await subscription.fetcher();
      const fetchTime = Date.now() - startTime;
      
      // Ï∫êÏãú ÏóÖÎç∞Ïù¥Ìä∏
      this.cache.set(key, {
        data,
        timestamp: new Date(),
        fetchTime
      });
      
      subscription.lastFetch = new Date();
      
      // Íµ¨ÎèÖÏûêÎì§ÏóêÍ≤å ÏïåÎ¶º
      subscription.subscribers.forEach(callback => {
        try {
          callback(data, null);
        } catch (error) {
          console.error('Subscriber callback error:', error);
        }
      });
      
      // Î©îÌä∏Î¶≠ Í∏∞Î°ù
      metricsService.trackDataSync(key, fetchTime, 'success');
      
    } catch (error) {
      console.error(`Data sync error for ${key}:`, error);
      
      // Íµ¨ÎèÖÏûêÎì§ÏóêÍ≤å ÏóêÎü¨ ÏïåÎ¶º
      subscription.subscribers.forEach(callback => {
        try {
          callback(null, error);
        } catch (callbackError) {
          console.error('Subscriber error callback error:', callbackError);
        }
      });
      
      // Î©îÌä∏Î¶≠ Í∏∞Î°ù
      metricsService.trackDataSync(key, 0, 'error', error.message);
    }
  }

  startSync(key) {
    const subscription = this.subscriptions.get(key);
    if (!subscription) return;

    // Ï¶âÏãú Ìïú Î≤à Ïã§Ìñâ
    this.fetchData(key);
    
    // Ï£ºÍ∏∞Ï†Å Ïã§Ìñâ ÏÑ§Ï†ï
    subscription.intervalId = setInterval(() => {
      this.fetchData(key);
    }, subscription.options.interval);
  }

  stopSync(key) {
    const subscription = this.subscriptions.get(key);
    if (subscription && subscription.intervalId) {
      clearInterval(subscription.intervalId);
      subscription.intervalId = null;
    }
  }

  unsubscribe(key) {
    this.stopSync(key);
    this.subscriptions.delete(key);
    this.cache.delete(key);
  }

  pauseSync() {
    this.subscriptions.forEach((_, key) => {
      this.stopSync(key);
    });
  }

  resumeSync() {
    this.subscriptions.forEach((_, key) => {
      this.startSync(key);
    });
  }
}

// ÏÇ¨Ïö©ÏùÑ ÏúÑÌïú React ÌõÖ
export const useRealtimeData = (key, fetcher, options = {}) => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [lastUpdate, setLastUpdate] = useState(null);

  const dataSynchronizer = useMemo(() => {
    return new DataSynchronizer();
  }, []);

  useEffect(() => {
    const subscription = dataSynchronizer.subscribe(key, fetcher, options);
    
    const handleDataUpdate = (newData, error) => {
      if (error) {
        setError(error);
        setLoading(false);
      } else {
        setData(newData);
        setError(null);
        setLoading(false);
        setLastUpdate(new Date());
      }
    };

    dataSynchronizer.addSubscriber(key, handleDataUpdate);

    return () => {
      dataSynchronizer.removeSubscriber(key, handleDataUpdate);
      subscription.unsubscribe();
    };
  }, [key, fetcher, options, dataSynchronizer]);

  const refresh = useCallback(() => {
    setLoading(true);
    dataSynchronizer.fetchData(key);
  }, [key, dataSynchronizer]);

  return {
    data,
    loading,
    error,
    lastUpdate,
    refresh
  };
};

// ÏÇ¨Ïö© ÏòàÏ†ú
const WeatherDataComponent = () => {
  const { data, loading, error, lastUpdate, refresh } = useRealtimeData(
    'weather-bukit-timah',
    () => weatherAPI.getWeatherData('bukit_timah_nature_reserve'),
    {
      interval: 2 * 60 * 1000, // 2Î∂Ñ Í∞ÑÍ≤©
      priority: 'high'
    }
  );

  if (loading) return <LoadingSpinner />;
  if (error) return <ErrorDisplay error={error} onRetry={refresh} />;

  return (
    <div>
      <WeatherDisplay data={data} />
      <div className="last-update">
        Last updated: {lastUpdate?.toLocaleTimeString()}
      </div>
    </div>
  );
};
```

---

## üö® ÏóêÎü¨ Ï≤òÎ¶¨ Ìå®ÌÑ¥

### 1. Error Boundary Ìå®ÌÑ¥

#### **Í≥ÑÏ∏µÏ†Å ÏóêÎü¨ Ï≤òÎ¶¨**

```javascript
/**
 * Í≥ÑÏ∏µÏ†Å ÏóêÎü¨ Ï≤òÎ¶¨ ÏãúÏä§ÌÖú
 */

// Í∏∞Î≥∏ Error Boundary
class BaseErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { 
      hasError: false, 
      error: null, 
      errorInfo: null,
      errorId: null
    };
  }

  static getDerivedStateFromError(error) {
    return { 
      hasError: true, 
      errorId: generateErrorId()
    };
  }

  componentDidCatch(error, errorInfo) {
    const errorData = {
      error,
      errorInfo,
      errorId: this.state.errorId,
      timestamp: new Date().toISOString(),
      url: window.location.href,
      userAgent: navigator.userAgent,
      componentStack: errorInfo.componentStack
    };

    this.setState({ error, errorInfo });
    
    // ÏóêÎü¨ Î¶¨Ìè¨ÌåÖ
    this.reportError(errorData);
  }

  reportError(errorData) {
    // Ìó¨Ïä§ ÏÑúÎπÑÏä§Ïóê ÏóêÎü¨ Í∏∞Î°ù
    if (window.healthService) {
      window.healthService.recordError(errorData.error, {
        type: 'react_error_boundary',
        errorId: errorData.errorId,
        componentStack: errorData.errorInfo.componentStack
      });
    }

    // Î©îÌä∏Î¶≠ ÏÑúÎπÑÏä§Ïóê ÏóêÎü¨ Ï∂îÏ†Å
    if (window.metricsService) {
      window.metricsService.trackError('react_component_error', {
        errorId: errorData.errorId,
        message: errorData.error.message,
        stack: errorData.error.stack
      });
    }

    // Í∞úÎ∞ú ÌôòÍ≤ΩÏóêÏÑúÎäî ÏΩòÏÜîÏóê ÏÉÅÏÑ∏ Ï†ïÎ≥¥ Ï∂úÎ†•
    if (process.env.NODE_ENV === 'development') {
      console.group('üö® React Error Boundary');
      console.error('Error ID:', errorData.errorId);
      console.error('Error:', errorData.error);
      console.error('Component Stack:', errorData.errorInfo.componentStack);
      console.groupEnd();
    }
  }

  handleRetry = () => {
    this.setState({ hasError: false, error: null, errorInfo: null });
  };

  render() {
    if (this.state.hasError) {
      const { fallback: Fallback, onRetry } = this.props;
      
      if (Fallback) {
        return (
          <Fallback 
            error={this.state.error}
            errorInfo={this.state.errorInfo}
            errorId={this.state.errorId}
            onRetry={onRetry || this.handleRetry}
          />
        );
      }

      return this.renderDefaultFallback();
    }

    return this.props.children;
  }

  renderDefaultFallback() {
    return (
      <div className="error-boundary-fallback" role="alert">
        <h2>Î¨∏Ï†úÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§</h2>
        <details>
          <summary>ÏóêÎü¨ ÏÉÅÏÑ∏ Ï†ïÎ≥¥</summary>
          <p>Error ID: {this.state.errorId}</p>
          <pre>{this.state.error?.message}</pre>
        </details>
        <button onClick={this.handleRetry}>
          Îã§Ïãú ÏãúÎèÑ
        </button>
      </div>
    );
  }
}

// ÌäπÌôîÎêú Error BoundaryÎì§
class WeatherErrorBoundary extends BaseErrorBoundary {
  renderDefaultFallback() {
    return (
      <div className="weather-error-fallback">
        <h3>ÎÇ†Ïî® Ï†ïÎ≥¥Î•º Î∂àÎü¨Ïò¨ Ïàò ÏóÜÏäµÎãàÎã§</h3>
        <p>Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.</p>
        <button onClick={this.handleRetry}>
          ÎÇ†Ïî® Ï†ïÎ≥¥ ÏÉàÎ°úÍ≥†Ïπ®
        </button>
      </div>
    );
  }
}

class NetworkErrorBoundary extends BaseErrorBoundary {
  renderDefaultFallback() {
    return (
      <div className="network-error-fallback">
        <h3>ÎÑ§Ìä∏ÏõåÌÅ¨ Ïó∞Í≤∞ Î¨∏Ï†ú</h3>
        <p>Ïù∏ÌÑ∞ÎÑ∑ Ïó∞Í≤∞ÏùÑ ÌôïÏù∏ÌïòÍ≥† Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.</p>
        <button onClick={this.handleRetry}>
          Ïó∞Í≤∞ Îã§Ïãú ÏãúÎèÑ
        </button>
      </div>
    );
  }
}

// ÏÇ¨Ïö© ÏòàÏ†ú
const App = () => (
  <BaseErrorBoundary fallback={AppErrorFallback}>
    <Header />
    
    <WeatherErrorBoundary>
      <WeatherSection />
    </WeatherErrorBoundary>
    
    <NetworkErrorBoundary>
      <TrafficCameraSection />
    </NetworkErrorBoundary>
    
    <Footer />
  </BaseErrorBoundary>
);
```

### 2. ÎπÑÎèôÍ∏∞ ÏóêÎü¨ Ï≤òÎ¶¨

#### **Promise Î∞è async/await ÏóêÎü¨ Ï≤òÎ¶¨**

```javascript
/**
 * ÎπÑÎèôÍ∏∞ ÏûëÏóÖ ÏóêÎü¨ Ï≤òÎ¶¨ Ìå®ÌÑ¥
 */

// Ïû¨ÏãúÎèÑ Î°úÏßÅÏù¥ Ìè¨Ìï®Îêú ÎπÑÎèôÍ∏∞ Ìï®Ïàò
const withRetry = async (asyncFn, maxRetries = 3, delay = 1000) => {
  let lastError;
  
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await asyncFn();
    } catch (error) {
      lastError = error;
      
      // Ïû¨ÏãúÎèÑ Î∂àÍ∞ÄÎä•Ìïú ÏóêÎü¨Îäî Ï¶âÏãú throw
      if (error.status === 404 || error.status === 403) {
        throw error;
      }
      
      // ÎßàÏßÄÎßâ ÏãúÎèÑÍ∞Ä ÏïÑÎãàÎ©¥ ÎåÄÍ∏∞ ÌõÑ Ïû¨ÏãúÎèÑ
      if (attempt < maxRetries) {
        await new Promise(resolve => setTimeout(resolve, delay * attempt));
      }
    }
  }
  
  throw lastError;
};

// ÌÉÄÏûÑÏïÑÏõÉÏù¥ Ìè¨Ìï®Îêú ÎπÑÎèôÍ∏∞ Ìï®Ïàò
const withTimeout = (asyncFn, timeoutMs = 10000) => {
  return Promise.race([
    asyncFn(),
    new Promise((_, reject) => 
      setTimeout(() => reject(new Error(`Timeout after ${timeoutMs}ms`)), timeoutMs)
    )
  ]);
};

// ÏïàÏ†ÑÌïú ÎπÑÎèôÍ∏∞ Ìò∏Ï∂úÏùÑ ÏúÑÌïú Ïª§Ïä§ÌÖÄ ÌõÖ
export const useSafeAsync = () => {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const isMountedRef = useRef(true);

  useEffect(() => {
    return () => {
      isMountedRef.current = false;
    };
  }, []);

  const execute = useCallback(async (asyncFn, options = {}) => {
    const {
      maxRetries = 3,
      timeout = 10000,
      onSuccess,
      onError
    } = options;

    try {
      if (!isMountedRef.current) return;
      
      setLoading(true);
      setError(null);

      const result = await withTimeout(
        () => withRetry(asyncFn, maxRetries),
        timeout
      );

      if (!isMountedRef.current) return;

      setLoading(false);
      
      if (onSuccess) {
        onSuccess(result);
      }
      
      return result;

    } catch (err) {
      if (!isMountedRef.current) return;

      setLoading(false);
      setError(err);
      
      if (onError) {
        onError(err);
      } else {
        // Í∏∞Î≥∏ ÏóêÎü¨ Ï≤òÎ¶¨
        console.error('Async operation failed:', err);
      }
      
      throw err;
    }
  }, []);

  const reset = useCallback(() => {
    setLoading(false);
    setError(null);
  }, []);

  return {
    loading,
    error,
    execute,
    reset
  };
};

// ÏÇ¨Ïö© ÏòàÏ†ú
const WeatherDataComponent = () => {
  const [weatherData, setWeatherData] = useState(null);
  const { loading, error, execute } = useSafeAsync();

  const fetchWeatherData = useCallback(async () => {
    await execute(
      () => weatherAPI.getWeatherData('bukit_timah'),
      {
        maxRetries: 3,
        timeout: 15000,
        onSuccess: setWeatherData,
        onError: (error) => {
          // ÏÇ¨Ïö©Ïûê ÏπúÌôîÏ†Å ÏóêÎü¨ Î©îÏãúÏßÄ
          const userMessage = error.status === 404 
            ? 'Ìï¥Îãπ ÏßÄÏó≠Ïùò ÎÇ†Ïî® Ï†ïÎ≥¥Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.'
            : 'ÎÇ†Ïî® Ï†ïÎ≥¥Î•º Î∂àÎü¨Ïò§Îäî Ï§ë Î¨∏Ï†úÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.';
          
          showNotification(userMessage, 'error');
        }
      }
    );
  }, [execute]);

  useEffect(() => {
    fetchWeatherData();
  }, [fetchWeatherData]);

  if (loading) return <LoadingSpinner />;
  if (error) return <ErrorDisplay error={error} onRetry={fetchWeatherData} />;
  if (!weatherData) return <EmptyState />;

  return <WeatherDisplay data={weatherData} />;
};
```

---

## ‚ö° ÏÑ±Îä• ÏµúÏ†ÅÌôî Ìå®ÌÑ¥

### 1. Î©îÎ™®Ïù¥Ï†úÏù¥ÏÖò Ìå®ÌÑ¥

#### **ÏßÄÎä•Ìòï Î©îÎ™®Ïù¥Ï†úÏù¥ÏÖò**

```javascript
/**
 * ÏßÄÎä•Ìòï Î©îÎ™®Ïù¥Ï†úÏù¥ÏÖò Ìå®ÌÑ¥
 */

// ÍπäÏùÄ ÎπÑÍµêÎ•º ÏúÑÌïú Ïª§Ïä§ÌÖÄ Î©îÎ™®Ïù¥Ï†úÏù¥ÏÖò
const useDeepMemo = (factory, deps) => {
  const ref = useRef();
  
  if (!ref.current || !deepEqual(deps, ref.current.deps)) {
    ref.current = {
      deps,
      value: factory()
    };
  }
  
  return ref.current.value;
};

// Ï°∞Í±¥Î∂Ä Î©îÎ™®Ïù¥Ï†úÏù¥ÏÖò
const useConditionalMemo = (factory, deps, condition = true) => {
  const memoizedValue = useMemo(factory, deps);
  const [cachedValue, setCachedValue] = useState(memoizedValue);
  
  useEffect(() => {
    if (condition) {
      setCachedValue(memoizedValue);
    }
  }, [memoizedValue, condition]);
  
  return condition ? memoizedValue : cachedValue;
};

// Ïã§Ï†ú ÏÇ¨Ïö© ÏòàÏ†ú
const WeatherAnalysisCard = React.memo(({ location, preferences }) => {
  // Î¨¥Í±∞Ïö¥ Í≥ÑÏÇ∞ÏùÑ Î©îÎ™®Ïù¥Ï†úÏù¥ÏÖò
  const analysisData = useMemo(() => {
    console.log('Calculating weather analysis for', location.id);
    
    return {
      comfort: calculateComfortIndex(location.temperature, location.humidity),
      activities: analyzeActivitySuitability(location),
      alerts: generateWeatherAlerts(location),
      forecast: processForecastData(location.forecast)
    };
  }, [
    location.temperature,
    location.humidity, 
    location.condition,
    location.forecast
  ]);

  // ÏÇ¨Ïö©Ïûê ÏÑ§Ï†ïÏóê Îî∞Î•∏ Ï°∞Í±¥Î∂Ä Î©îÎ™®Ïù¥Ï†úÏù¥ÏÖò
  const personalizedData = useConditionalMemo(
    () => personalizeWeatherData(analysisData, preferences),
    [analysisData, preferences],
    preferences.enablePersonalization
  );

  // Î†åÎçîÎßÅ ÏµúÏ†ÅÌôî
  const cardStyle = useMemo(() => ({
    '--temperature-color': getTemperatureColor(location.temperature),
    '--humidity-opacity': location.humidity / 100,
    animationDelay: `${Math.random() * 200}ms`
  }), [location.temperature, location.humidity]);

  return (
    <div className="weather-analysis-card" style={cardStyle}>
      <WeatherCardHeader location={location} />
      <WeatherMetrics data={personalizedData} />
      <ActivityRecommendations activities={analysisData.activities} />
    </div>
  );
}, (prevProps, nextProps) => {
  // Ïª§Ïä§ÌÖÄ ÎπÑÍµê Ìï®ÏàòÎ°ú Î¶¨Î†åÎçîÎßÅ ÏµúÏ†ÅÌôî
  return (
    prevProps.location.id === nextProps.location.id &&
    prevProps.location.temperature === nextProps.location.temperature &&
    prevProps.location.humidity === nextProps.location.humidity &&
    prevProps.location.condition === nextProps.location.condition &&
    shallowEqual(prevProps.preferences, nextProps.preferences)
  );
});
```

### 2. Í∞ÄÏÉÅ Ïä§ÌÅ¨Î°§ÎßÅ Ìå®ÌÑ¥

#### **Î¨¥Ìïú Ïä§ÌÅ¨Î°§ + Í∞ÄÏÉÅ Ïä§ÌÅ¨Î°§ÎßÅ**

```javascript
/**
 * Ìö®Ïú®Ï†ÅÏù∏ ÎåÄÏö©Îüâ Î¶¨Ïä§Ìä∏ Î†åÎçîÎßÅ
 */

const useVirtualScroll = ({ 
  items, 
  itemHeight, 
  containerHeight, 
  overscan = 5 
}) => {
  const [scrollTop, setScrollTop] = useState(0);
  
  const visibleRange = useMemo(() => {
    const startIndex = Math.floor(scrollTop / itemHeight);
    const endIndex = Math.min(
      startIndex + Math.ceil(containerHeight / itemHeight) + overscan,
      items.length
    );
    
    return {
      startIndex: Math.max(0, startIndex - overscan),
      endIndex
    };
  }, [scrollTop, itemHeight, containerHeight, overscan, items.length]);
  
  const visibleItems = useMemo(() => {
    return items.slice(visibleRange.startIndex, visibleRange.endIndex)
      .map((item, index) => ({
        ...item,
        index: visibleRange.startIndex + index
      }));
  }, [items, visibleRange]);
  
  const totalHeight = items.length * itemHeight;
  const offsetY = visibleRange.startIndex * itemHeight;
  
  return {
    visibleItems,
    totalHeight,
    offsetY,
    setScrollTop
  };
};

// Î¨¥Ìïú Ïä§ÌÅ¨Î°§ ÌõÖ
const useInfiniteScroll = ({ 
  fetchMore, 
  hasMore, 
  threshold = 200 
}) => {
  const [loading, setLoading] = useState(false);
  const observerRef = useRef();
  
  const loadMore = useCallback(async () => {
    if (loading || !hasMore) return;
    
    setLoading(true);
    try {
      await fetchMore();
    } finally {
      setLoading(false);
    }
  }, [loading, hasMore, fetchMore]);
  
  const lastElementRef = useCallback((node) => {
    if (loading) return;
    
    if (observerRef.current) observerRef.current.disconnect();
    
    observerRef.current = new IntersectionObserver(entries => {
      if (entries[0].isIntersecting && hasMore) {
        loadMore();
      }
    }, { threshold: 0.1 });
    
    if (node) observerRef.current.observe(node);
  }, [loading, hasMore, loadMore]);
  
  return { loading, lastElementRef };
};

// Ï°∞Ìï©Îêú Î¨¥Ìïú Í∞ÄÏÉÅ Ïä§ÌÅ¨Î°§ Ïª¥Ìè¨ÎÑåÌä∏
const VirtualizedTrafficCameraList = ({ 
  initialCameras, 
  fetchMoreCameras 
}) => {
  const [cameras, setCameras] = useState(initialCameras);
  const [hasMore, setHasMore] = useState(true);
  const containerRef = useRef();
  const [containerHeight, setContainerHeight] = useState(600);
  
  const ITEM_HEIGHT = 200;
  
  const { visibleItems, totalHeight, offsetY, setScrollTop } = useVirtualScroll({
    items: cameras,
    itemHeight: ITEM_HEIGHT,
    containerHeight,
    overscan: 3
  });
  
  const { loading, lastElementRef } = useInfiniteScroll({
    fetchMore: async () => {
      const newCameras = await fetchMoreCameras();
      if (newCameras.length === 0) {
        setHasMore(false);
      } else {
        setCameras(prev => [...prev, ...newCameras]);
      }
    },
    hasMore
  });
  
  // Ïª®ÌÖåÏù¥ÎÑà ÌÅ¨Í∏∞ Í∞êÏßÄ
  useEffect(() => {
    const observer = new ResizeObserver(entries => {
      if (entries[0]) {
        setContainerHeight(entries[0].contentRect.height);
      }
    });
    
    if (containerRef.current) {
      observer.observe(containerRef.current);
    }
    
    return () => observer.disconnect();
  }, []);
  
  const handleScroll = useCallback((e) => {
    setScrollTop(e.target.scrollTop);
  }, [setScrollTop]);
  
  return (
    <div
      ref={containerRef}
      className="virtual-scroll-container"
      style={{ height: containerHeight, overflow: 'auto' }}
      onScroll={handleScroll}
    >
      <div style={{ height: totalHeight, position: 'relative' }}>
        <div
          style={{
            transform: `translateY(${offsetY}px)`,
            position: 'absolute',
            top: 0,
            left: 0,
            right: 0
          }}
        >
          {visibleItems.map((camera, index) => {
            const isLast = index === visibleItems.length - 1;
            
            return (
              <div
                key={camera.id}
                ref={isLast ? lastElementRef : null}
                style={{ height: ITEM_HEIGHT }}
              >
                <CameraCard camera={camera} />
              </div>
            );
          })}
          
          {loading && (
            <div className="loading-more" style={{ height: ITEM_HEIGHT }}>
              <LoadingSpinner />
              <span>Îçî ÎßéÏùÄ Ïπ¥Î©îÎùºÎ•º Î∂àÎü¨Ïò§Îäî Ï§ë...</span>
            </div>
          )}
        </div>
      </div>
    </div>
  );
};
```

---

## üß™ ÌÖåÏä§ÌåÖ Ìå®ÌÑ¥

### 1. Ïª¥Ìè¨ÎÑåÌä∏ ÌÖåÏä§ÌåÖ

#### **Ï¢ÖÌï©Ï†ÅÏù∏ Ïª¥Ìè¨ÎÑåÌä∏ ÌÖåÏä§Ìä∏**

```javascript
/**
 * React Testing LibraryÎ•º ÌôúÏö©Ìïú Ïª¥Ìè¨ÎÑåÌä∏ ÌÖåÏä§Ìä∏
 */

import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { jest } from '@jest/globals';

// ÌÖåÏä§Ìä∏ Ïú†Ìã∏Î¶¨Ìã∞
const renderWithProviders = (component, options = {}) => {
  const {
    initialState = {},
    theme = 'light',
    ...renderOptions
  } = options;

  const AllTheProviders = ({ children }) => (
    <AppStateProvider initialState={initialState}>
      <ThemeProvider theme={theme}>
        {children}
      </ThemeProvider>
    </AppStateProvider>
  );

  return render(component, { wrapper: AllTheProviders, ...renderOptions });
};

// Î™®ÌÇπ Ìï®ÏàòÎì§
const mockWeatherAPI = {
  getWeatherData: jest.fn(),
  getTrafficCameras: jest.fn()
};

const mockMetricsService = {
  trackUserInteraction: jest.fn(),
  trackAPICall: jest.fn()
};

// WeatherCard Ïª¥Ìè¨ÎÑåÌä∏ ÌÖåÏä§Ìä∏
describe('WeatherCard', () => {
  const mockLocation = {
    id: 'bukit_timah',
    displayName: 'Bukit Timah Nature Reserve',
    temperature: 28.5,
    humidity: 75,
    condition: 'partly_cloudy'
  };

  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('renders weather information correctly', () => {
    renderWithProviders(
      <WeatherCard 
        location={mockLocation}
        onRefresh={() => {}}
      />
    );

    expect(screen.getByText('Bukit Timah Nature Reserve')).toBeInTheDocument();
    expect(screen.getByLabelText(/temperature 28.5 degrees/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/humidity 75 percent/i)).toBeInTheDocument();
  });

  it('calls onRefresh when refresh button is clicked', async () => {
    const user = userEvent.setup();
    const mockRefresh = jest.fn();

    renderWithProviders(
      <WeatherCard 
        location={mockLocation}
        onRefresh={mockRefresh}
      />
    );

    const refreshButton = screen.getByRole('button', { 
      name: /refresh weather data for bukit timah/i 
    });
    
    await user.click(refreshButton);
    
    expect(mockRefresh).toHaveBeenCalledTimes(1);
  });

  it('shows loading state correctly', () => {
    renderWithProviders(
      <WeatherCard 
        location={mockLocation}
        onRefresh={() => {}}
        isLoading={true}
      />
    );

    expect(screen.getByText('Updating...')).toBeInTheDocument();
    expect(screen.queryByRole('button')).not.toBeInTheDocument();
  });

  it('handles keyboard navigation properly', async () => {
    const user = userEvent.setup();
    const mockRefresh = jest.fn();

    renderWithProviders(
      <WeatherCard 
        location={mockLocation}
        onRefresh={mockRefresh}
      />
    );

    const refreshButton = screen.getByRole('button');
    
    // ÌÉ≠ÏúºÎ°ú Ìè¨Ïª§Ïä§ Ïù¥Îèô
    await user.tab();
    expect(refreshButton).toHaveFocus();
    
    // ÏóîÌÑ∞ÌÇ§Î°ú ÌÅ¥Î¶≠
    await user.keyboard('{Enter}');
    expect(mockRefresh).toHaveBeenCalledTimes(1);
  });
});

// Ïª§Ïä§ÌÖÄ ÌõÖ ÌÖåÏä§Ìä∏
describe('useWeatherData', () => {
  beforeEach(() => {
    mockWeatherAPI.getWeatherData.mockResolvedValue({
      location: mockLocation,
      temperature: 28.5,
      humidity: 75
    });
  });

  it('fetches data on mount', async () => {
    const { result } = renderHook(() => 
      useWeatherData('bukit_timah')
    );

    expect(result.current.loading).toBe(true);
    
    await waitFor(() => {
      expect(result.current.loading).toBe(false);
    });
    
    expect(result.current.data).toBeDefined();
    expect(mockWeatherAPI.getWeatherData).toHaveBeenCalledWith('bukit_timah');
  });

  it('handles errors correctly', async () => {
    const errorMessage = 'Network error';
    mockWeatherAPI.getWeatherData.mockRejectedValue(new Error(errorMessage));

    const { result } = renderHook(() => 
      useWeatherData('bukit_timah')
    );

    await waitFor(() => {
      expect(result.current.loading).toBe(false);
    });
    
    expect(result.current.error).toBeDefined();
    expect(result.current.error.message).toBe(errorMessage);
  });

  it('refreshes data when refresh is called', async () => {
    const { result } = renderHook(() => 
      useWeatherData('bukit_timah', { enableAutoRefresh: false })
    );

    await waitFor(() => {
      expect(result.current.loading).toBe(false);
    });

    expect(mockWeatherAPI.getWeatherData).toHaveBeenCalledTimes(1);
    
    act(() => {
      result.current.refresh();
    });

    await waitFor(() => {
      expect(mockWeatherAPI.getWeatherData).toHaveBeenCalledTimes(2);
    });
  });
});
```

### 2. ÌÜµÌï© ÌÖåÏä§Ìä∏

#### **E2E ÌÖåÏä§Ìä∏ Ìå®ÌÑ¥**

```javascript
/**
 * PlaywrightÎ•º ÌôúÏö©Ìïú E2E ÌÖåÏä§Ìä∏
 */

import { test, expect } from '@playwright/test';

// ÌéòÏù¥ÏßÄ Í∞ùÏ≤¥ Î™®Îç∏
class WeatherAppPage {
  constructor(page) {
    this.page = page;
    this.weatherCards = page.locator('[data-testid="weather-card"]');
    this.refreshButton = page.locator('[data-testid="refresh-all"]');
    this.locationSelector = page.locator('[data-testid="location-selector"]');
    this.mapContainer = page.locator('[data-testid="map-container"]');
  }

  async goto() {
    await this.page.goto('/');
    await this.waitForLoad();
  }

  async waitForLoad() {
    await expect(this.weatherCards.first()).toBeVisible();
    await this.page.waitForLoadState('networkidle');
  }

  async selectLocation(locationName) {
    await this.locationSelector.selectOption(locationName);
    await this.waitForLoad();
  }

  async refreshWeatherData() {
    await this.refreshButton.click();
    await this.waitForLoad();
  }

  async getWeatherCardData(index = 0) {
    const card = this.weatherCards.nth(index);
    const temperature = await card.locator('[data-testid="temperature"]').textContent();
    const humidity = await card.locator('[data-testid="humidity"]').textContent();
    const location = await card.locator('[data-testid="location-name"]').textContent();
    
    return { temperature, humidity, location };
  }
}

test.describe('Weather App E2E Tests', () => {
  let weatherPage;

  test.beforeEach(async ({ page }) => {
    weatherPage = new WeatherAppPage(page);
    await weatherPage.goto();
  });

  test('displays weather data correctly', async () => {
    const weatherData = await weatherPage.getWeatherCardData(0);
    
    expect(weatherData.location).toBeTruthy();
    expect(weatherData.temperature).toMatch(/\d+\.?\d*¬∞C/);
    expect(weatherData.humidity).toMatch(/\d+%/);
  });

  test('refreshes data when refresh button is clicked', async ({ page }) => {
    // Ï¥àÍ∏∞ Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞
    const initialData = await weatherPage.getWeatherCardData(0);
    
    // API ÏöîÏ≤≠ Î™®ÎãàÌÑ∞ÎßÅ
    const apiPromise = page.waitForResponse(
      response => response.url().includes('/weather') && response.status() === 200
    );
    
    await weatherPage.refreshWeatherData();
    await apiPromise;
    
    // Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÖÎç∞Ïù¥Ìä∏ÎêòÏóàÎäîÏßÄ ÌôïÏù∏ (ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑ Îì±ÏúºÎ°ú)
    const lastUpdate = await page.locator('[data-testid="last-update"]').textContent();
    expect(lastUpdate).toContain('ago');
  });

  test('handles network errors gracefully', async ({ page }) => {
    // ÎÑ§Ìä∏ÏõåÌÅ¨ Ï∞®Îã®
    await page.route('**/api/weather/**', route => {
      route.abort('failed');
    });

    await weatherPage.refreshWeatherData();
    
    // ÏóêÎü¨ Î©îÏãúÏßÄ ÌôïÏù∏
    await expect(page.locator('[data-testid="error-message"]')).toBeVisible();
    
    // Ïû¨ÏãúÎèÑ Î≤ÑÌäº ÌôïÏù∏
    const retryButton = page.locator('[data-testid="retry-button"]');
    await expect(retryButton).toBeVisible();
  });

  test('supports keyboard navigation', async ({ page }) => {
    // Ï≤´ Î≤àÏß∏ Ïπ¥ÎìúÎ°ú Ìè¨Ïª§Ïä§ Ïù¥Îèô
    await page.keyboard.press('Tab');
    
    const focusedElement = await page.evaluate(() => document.activeElement.getAttribute('data-testid'));
    expect(focusedElement).toBe('weather-card');
    
    // ÏóîÌÑ∞ÌÇ§Î°ú ÏÉÅÏÑ∏ Ï†ïÎ≥¥ ÌÜ†Í∏Ä
    await page.keyboard.press('Enter');
    await expect(page.locator('[data-testid="weather-details"]')).toBeVisible();
  });

  test('works offline', async ({ page, context }) => {
    // Ïò®ÎùºÏù∏ ÏÉÅÌÉúÏóêÏÑú Îç∞Ïù¥ÌÑ∞ Î°úÎìú
    await weatherPage.waitForLoad();
    const onlineData = await weatherPage.getWeatherCardData(0);
    
    // Ïò§ÌîÑÎùºÏù∏ Î™®Îìú ÌôúÏÑ±Ìôî
    await context.setOffline(true);
    await page.reload();
    
    // Ï∫êÏãúÎêú Îç∞Ïù¥ÌÑ∞ ÌôïÏù∏
    await expect(page.locator('[data-testid="offline-indicator"]')).toBeVisible();
    
    const offlineData = await weatherPage.getWeatherCardData(0);
    expect(offlineData.location).toBe(onlineData.location);
  });

  test('responsive design on mobile', async ({ page }) => {
    // Î™®Î∞îÏùº Î∑∞Ìè¨Ìä∏Î°ú Î≥ÄÍ≤Ω
    await page.setViewportSize({ width: 375, height: 667 });
    
    // Ïπ¥ÎìúÍ∞Ä ÏÑ∏Î°úÎ°ú Ï†ïÎ†¨ÎêòÎäîÏßÄ ÌôïÏù∏
    const cards = await page.locator('[data-testid="weather-card"]').all();
    
    for (let i = 0; i < cards.length - 1; i++) {
      const currentCard = cards[i];
      const nextCard = cards[i + 1];
      
      const currentBox = await currentCard.boundingBox();
      const nextBox = await nextCard.boundingBox();
      
      // Îã§Ïùå Ïπ¥ÎìúÍ∞Ä ÌòÑÏû¨ Ïπ¥Îìú ÏïÑÎûòÏóê ÏûàÎäîÏßÄ ÌôïÏù∏
      expect(nextBox.y).toBeGreaterThan(currentBox.y + currentBox.height - 10);
    }
  });
});
```

---

## ‚ôø Ï†ëÍ∑ºÏÑ± Ìå®ÌÑ¥

### 1. ÌÇ§Î≥¥Îìú ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò

#### **Ìè¨Í¥ÑÏ†ÅÏù∏ ÌÇ§Î≥¥Îìú ÏßÄÏõê**

```javascript
/**
 * ÌÇ§Î≥¥Îìú ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò Ìå®ÌÑ¥
 */

// ÌÇ§Î≥¥Îìú Ìä∏Îû© ÌõÖ
const useFocusTrap = (isActive) => {
  const containerRef = useRef();
  
  useEffect(() => {
    if (!isActive || !containerRef.current) return;
    
    const container = containerRef.current;
    const focusableElements = container.querySelectorAll(
      'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
    );
    
    const firstElement = focusableElements[0];
    const lastElement = focusableElements[focusableElements.length - 1];
    
    const handleTabKey = (e) => {
      if (e.key !== 'Tab') return;
      
      if (e.shiftKey) {
        if (document.activeElement === firstElement) {
          e.preventDefault();
          lastElement.focus();
        }
      } else {
        if (document.activeElement === lastElement) {
          e.preventDefault();
          firstElement.focus();
        }
      }
    };
    
    const handleEscapeKey = (e) => {
      if (e.key === 'Escape') {
        // Î™®Îã¨Ïù¥ÎÇò ÎìúÎ°≠Îã§Ïö¥ Îã´Í∏∞
        if (typeof onEscape === 'function') {
          onEscape();
        }
      }
    };
    
    container.addEventListener('keydown', handleTabKey);
    container.addEventListener('keydown', handleEscapeKey);
    
    // Ï¥àÍ∏∞ Ìè¨Ïª§Ïä§ ÏÑ§Ï†ï
    firstElement?.focus();
    
    return () => {
      container.removeEventListener('keydown', handleTabKey);
      container.removeEventListener('keydown', handleEscapeKey);
    };
  }, [isActive]);
  
  return containerRef;
};

// Ï†ëÍ∑º Í∞ÄÎä•Ìïú Î™®Îã¨ Ïª¥Ìè¨ÎÑåÌä∏
const AccessibleModal = ({ 
  isOpen, 
  onClose, 
  title, 
  children,
  closeButtonLabel = "Îã´Í∏∞"
}) => {
  const modalRef = useFocusTrap(isOpen);
  const titleId = useId();
  
  // Î™®Îã¨Ïù¥ Ïó¥Î¶¥ Îïå body Ïä§ÌÅ¨Î°§ Î∞©ÏßÄ
  useEffect(() => {
    if (isOpen) {
      document.body.style.overflow = 'hidden';
      return () => {
        document.body.style.overflow = 'unset';
      };
    }
  }, [isOpen]);
  
  // Ïä§ÌÅ¨Î¶∞ Î¶¨ÎçîÎ•º ÏúÑÌïú ÎùºÏù¥Î∏å Î¶¨Ï†Ñ ÏóÖÎç∞Ïù¥Ìä∏
  useEffect(() => {
    if (isOpen) {
      announceToScreenReader(`Î™®Îã¨Ïù¥ Ïó¥Î†∏ÏäµÎãàÎã§: ${title}`);
    }
  }, [isOpen, title]);
  
  if (!isOpen) return null;
  
  return createPortal(
    <div 
      className="modal-overlay"
      role="dialog"
      aria-modal="true"
      aria-labelledby={titleId}
      ref={modalRef}
    >
      <div className="modal-content">
        <header className="modal-header">
          <h2 id={titleId}>{title}</h2>
          <button 
            type="button"
            onClick={onClose}
            aria-label={closeButtonLabel}
            className="close-button"
          >
            ‚úï
          </button>
        </header>
        
        <div className="modal-body">
          {children}
        </div>
      </div>
    </div>,
    document.body
  );
};

// Ï†ëÍ∑º Í∞ÄÎä•Ìïú ÎìúÎ°≠Îã§Ïö¥ Î©îÎâ¥
const AccessibleDropdown = ({ 
  trigger, 
  children, 
  placement = 'bottom-start' 
}) => {
  const [isOpen, setIsOpen] = useState(false);
  const triggerRef = useRef();
  const menuRef = useFocusTrap(isOpen);
  const menuId = useId();
  
  const handleKeyDown = (e) => {
    switch (e.key) {
      case 'Enter':
      case ' ':
      case 'ArrowDown':
        e.preventDefault();
        setIsOpen(true);
        break;
      case 'Escape':
        setIsOpen(false);
        triggerRef.current?.focus();
        break;
    }
  };
  
  const handleMenuKeyDown = (e) => {
    const menuItems = menuRef.current?.querySelectorAll('[role="menuitem"]');
    const currentIndex = Array.from(menuItems || []).indexOf(e.target);
    
    switch (e.key) {
      case 'ArrowDown':
        e.preventDefault();
        const nextIndex = (currentIndex + 1) % menuItems.length;
        menuItems[nextIndex]?.focus();
        break;
        
      case 'ArrowUp':
        e.preventDefault();
        const prevIndex = currentIndex === 0 ? menuItems.length - 1 : currentIndex - 1;
        menuItems[prevIndex]?.focus();
        break;
        
      case 'Home':
        e.preventDefault();
        menuItems[0]?.focus();
        break;
        
      case 'End':
        e.preventDefault();
        menuItems[menuItems.length - 1]?.focus();
        break;
        
      case 'Escape':
        setIsOpen(false);
        triggerRef.current?.focus();
        break;
    }
  };
  
  return (
    <div className="dropdown">
      <button
        ref={triggerRef}
        type="button"
        aria-expanded={isOpen}
        aria-haspopup="menu"
        aria-controls={isOpen ? menuId : undefined}
        onKeyDown={handleKeyDown}
        onClick={() => setIsOpen(!isOpen)}
      >
        {trigger}
      </button>
      
      {isOpen && (
        <div
          ref={menuRef}
          id={menuId}
          role="menu"
          className={`dropdown-menu placement-${placement}`}
          onKeyDown={handleMenuKeyDown}
        >
          {children}
        </div>
      )}
    </div>
  );
};
```

### 2. Ïä§ÌÅ¨Î¶∞ Î¶¨Îçî ÏßÄÏõê

#### **ARIA Î∞è ÏãúÎ©òÌã± ÎßàÌÅ¨ÏóÖ**

```javascript
/**
 * Ïä§ÌÅ¨Î¶∞ Î¶¨Îçî ÏπúÌôîÏ†Å Ïª¥Ìè¨ÎÑåÌä∏
 */

// ÎùºÏù¥Î∏å Î¶¨Ï†Ñ Í¥ÄÎ¶¨
const useLiveRegion = () => {
  const announceRef = useRef();
  
  useEffect(() => {
    // ÎùºÏù¥Î∏å Î¶¨Ï†Ñ ÏÉùÏÑ±
    const liveRegion = document.createElement('div');
    liveRegion.setAttribute('aria-live', 'polite');
    liveRegion.setAttribute('aria-atomic', 'true');
    liveRegion.className = 'sr-only';
    document.body.appendChild(liveRegion);
    announceRef.current = liveRegion;
    
    return () => {
      if (announceRef.current) {
        document.body.removeChild(announceRef.current);
      }
    };
  }, []);
  
  const announce = useCallback((message, priority = 'polite') => {
    if (announceRef.current) {
      announceRef.current.setAttribute('aria-live', priority);
      announceRef.current.textContent = message;
      
      // Î©îÏãúÏßÄ ÌÅ¥Î¶¨Ïñ¥
      setTimeout(() => {
        if (announceRef.current) {
          announceRef.current.textContent = '';
        }
      }, 1000);
    }
  }, []);
  
  return { announce };
};

// Ï†ëÍ∑º Í∞ÄÎä•Ìïú Îç∞Ïù¥ÌÑ∞ ÌÖåÏù¥Î∏î
const AccessibleDataTable = ({ 
  data, 
  columns, 
  caption,
  sortable = false 
}) => {
  const [sortConfig, setSortConfig] = useState(null);
  const { announce } = useLiveRegion();
  const tableId = useId();
  
  const sortedData = useMemo(() => {
    if (!sortConfig) return data;
    
    return [...data].sort((a, b) => {
      const aValue = a[sortConfig.key];
      const bValue = b[sortConfig.key];
      
      if (aValue < bValue) return sortConfig.direction === 'asc' ? -1 : 1;
      if (aValue > bValue) return sortConfig.direction === 'asc' ? 1 : -1;
      return 0;
    });
  }, [data, sortConfig]);
  
  const handleSort = (columnKey, columnLabel) => {
    let direction = 'asc';
    
    if (sortConfig?.key === columnKey && sortConfig.direction === 'asc') {
      direction = 'desc';
    }
    
    setSortConfig({ key: columnKey, direction });
    
    // Ïä§ÌÅ¨Î¶∞ Î¶¨ÎçîÏóê Ï†ïÎ†¨ ÏÉÅÌÉú ÏïåÎ¶º
    announce(
      `ÌÖåÏù¥Î∏îÏù¥ ${columnLabel} Í∏∞Ï§ÄÏúºÎ°ú ${direction === 'asc' ? 'Ïò§Î¶ÑÏ∞®Ïàú' : 'ÎÇ¥Î¶ºÏ∞®Ïàú'} Ï†ïÎ†¨ÎêòÏóàÏäµÎãàÎã§.`
    );
  };
  
  return (
    <div className="table-container" role="region" aria-labelledby={`${tableId}-caption`}>
      <table 
        id={tableId}
        className="accessible-table"
        aria-describedby={sortable ? `${tableId}-sort-info` : undefined}
      >
        <caption id={`${tableId}-caption`}>
          {caption}
          {sortable && (
            <div id={`${tableId}-sort-info`} className="sr-only">
              Ï†ïÎ†¨ Í∞ÄÎä•Ìïú ÌÖåÏù¥Î∏îÏûÖÎãàÎã§. Ïó¥ Î®∏Î¶¨Í∏ÄÏùÑ ÌÅ¥Î¶≠ÌïòÍ±∞ÎÇò ÏóîÌÑ∞ÌÇ§Î•º ÎàÑÎ•¥Î©¥ Ìï¥Îãπ Ïó¥ÏùÑ Í∏∞Ï§ÄÏúºÎ°ú Ï†ïÎ†¨Îê©ÎãàÎã§.
            </div>
          )}
        </caption>
        
        <thead>
          <tr>
            {columns.map(column => (
              <th
                key={column.key}
                scope="col"
                className={sortable ? 'sortable' : ''}
                tabIndex={sortable ? 0 : undefined}
                role={sortable ? 'button' : undefined}
                aria-sort={
                  sortConfig?.key === column.key 
                    ? sortConfig.direction === 'asc' ? 'ascending' : 'descending'
                    : 'none'
                }
                onClick={sortable ? () => handleSort(column.key, column.label) : undefined}
                onKeyDown={sortable ? (e) => {
                  if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    handleSort(column.key, column.label);
                  }
                } : undefined}
              >
                {column.label}
                {sortable && (
                  <span className="sort-indicator" aria-hidden="true">
                    {sortConfig?.key === column.key 
                      ? (sortConfig.direction === 'asc' ? ' ‚Üë' : ' ‚Üì')
                      : ' ‚Üï'
                    }
                  </span>
                )}
              </th>
            ))}
          </tr>
        </thead>
        
        <tbody>
          {sortedData.map((row, rowIndex) => (
            <tr key={rowIndex}>
              {columns.map(column => (
                <td key={column.key}>
                  {column.render ? column.render(row[column.key], row) : row[column.key]}
                </td>
              ))}
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
};

// Ï†ëÍ∑º Í∞ÄÎä•Ìïú ÌîÑÎ°úÍ∑∏Î†àÏä§ Î∞î
const AccessibleProgressBar = ({ 
  value, 
  max = 100, 
  label,
  showPercentage = true 
}) => {
  const progressId = useId();
  const percentage = Math.round((value / max) * 100);
  
  return (
    <div className="progress-container">
      <div className="progress-label" id={`${progressId}-label`}>
        {label}
        {showPercentage && (
          <span className="progress-percentage" aria-hidden="true">
            {percentage}%
          </span>
        )}
      </div>
      
      <div
        role="progressbar"
        aria-valuenow={value}
        aria-valuemin={0}
        aria-valuemax={max}
        aria-labelledby={`${progressId}-label`}
        aria-valuetext={`${percentage}% ÏôÑÎ£å`}
        className="progress-bar"
      >
        <div 
          className="progress-fill"
          style={{ width: `${percentage}%` }}
        />
      </div>
      
      <div className="sr-only" aria-live="polite">
        {label} {percentage}% ÏôÑÎ£å
      </div>
    </div>
  );
};
```

Ïù¥ Íµ¨ÌòÑ Ìå®ÌÑ¥ Í∞ÄÏù¥ÎìúÎäî Singapore Weather Cam ÌîÑÎ°úÏ†ùÌä∏ÏóêÏÑú ÏÇ¨Ïö©Îêú Ïã§Ï†ú Ìå®ÌÑ¥Îì§ÏùÑ Í∏∞Î∞òÏúºÎ°ú ÏûëÏÑ±ÎêòÏóàÏúºÎ©∞, Í∞Å Ìå®ÌÑ¥ÏùÄ ÌîÑÎ°úÎçïÏÖò ÌôòÍ≤ΩÏóêÏÑú Í≤ÄÏ¶ùÎêú Î≤†Ïä§Ìä∏ ÌîÑÎûôÌã∞Ïä§Î•º Îî∞Î¶ÖÎãàÎã§. Ïù¥Îü¨Ìïú Ìå®ÌÑ¥Îì§ÏùÑ ÌôúÏö©ÌïòÏó¨ ÌôïÏû• Í∞ÄÎä•ÌïòÍ≥† Ïú†ÏßÄÎ≥¥ÏàòÍ∞Ä Ïö©Ïù¥Ìïú React Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖòÏùÑ Íµ¨Ï∂ïÌï† Ïàò ÏûàÏäµÎãàÎã§.